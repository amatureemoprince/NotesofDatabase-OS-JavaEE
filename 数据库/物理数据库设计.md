# 1.物理数据库设计概述

​	任务：在逻辑数据库设计的基础上，为每个关系模式选择合适的存取方法和存储结构，使得数据库上的事务能够高效地运行。

​	设计步骤：

​		1.分析数据库负载

​		2.选择关系数据库的存取方法

​		3. 设计关系数据库的物理存储结构

# 2.索引的设计

## 	2.1.索引

​	索引是能够帮助DBMS快速找到元组的数据结构

​	索引对于提高查询处理效率至关重要

​	索引的构成：

​		索引键：索引根据一组属性（索引键）来定位元组

​		索引纪录了元组的索引键值与元组地址的对应关系

​		索引项：索引中的键值和地址对

​		索引中的索引项按索引键值排序 

​		索引的分类：

​		主索引：索引键是关系的主键，只能有一个

​		二级索引：索引键不是关系的主键，可以有多个

​		聚簇索引：索引中存储的是元组本身，而不是元组的地址，这样可以节约时间

​		非聚簇索引：索引中存储的是元组地址

​	索引的创建、删除和查看

```sql
--建表时创建
index idx_name(索引属性);
--建表后创建
alter table tb_name add index idx_name(索引属性);

create index idx_name on tb_name(索引属性);
--删除索引
alter table tb_name drop index idx_name;

drop index idx_name on tb_name;
```

​		查看索引：

```SQL
show index from book;
```

## 	2.2.索引的数据结构

​			索引可以用多种数据结构实现

​				B+数：

​					B+树是大多数RDBMS所使用的索引结构

​					B+树是一颗平衡多叉树，所有叶节点的深度都相同

​					索引项全部存储在B+树的叶节点中，并按索引键值排序存储

​				B+树支持的查询：

​					全值匹配：就是所有索引键进行匹配

​					匹配最左前缀：让左侧的索引键进行匹配

​					匹配属性前缀：只匹配前缀属性的前缀部分

​					范围匹配：在给定范围内对前缀属性进行匹配

​					精确匹配某一属性并范围匹配另一属性：字面意思

​					支持按索引属性进行排序

​				B+树不支持的查询：

​					不从索引的最左属性开始查找

​					条件中包含表达式

​					跳过索引中的属性

​				哈希索引（不支持范围查询,不支持部分索引属性匹配，无法用于排序，存在冲突问题）	

```SQL
--创建表
create tb_hash_idx(
	Cno int,
    Cname varchar(20);
) engine = memory;
--创建哈希索引
create index hash_idx on tb_hash_idx using hash;
```

​				跳表

​			不同的索引结构具有不同的功能和特性

​		索引设计的过程

​			分析工作负载

​			依次检查每个重要的查询

​			权衡索引更新的代价 

​				增删改查的代价很高

​			**不适合使用索引的场合**

​				where、group by、order by不会涉及的字段

​				数据量小的表

​				有大量重复数据的列

​				经常更新的表，避免创建过多的索引

​				无序的值

​			设计技巧：

​				**伪哈希索引**

​				**前缀索引：**

​					当索引是很长的字符串时，索引会变得很大，而且很慢，在字符串的前缀具有较好的选择性时，可以只索引前缀。

​					选择性：在前缀长度取不同个数时，不同的比上所有的，为1最好。

![](G:\pictureWork\Typroapicture\屏幕截图 2024-06-04 082732.png)

![](G:\pictureWork\Typroapicture\屏幕截图 2024-06-04 082812.png)

​				**单个多属性索引和多个单属性索引：**					![](G:\pictureWork\Typroapicture\屏幕截图 2024-06-04 083452.png)

​					多个单属性索引的缺点：

​						效率没有在单个多属性索引上的查询高

​						索引合并需要消耗大量的计算和存储资源

​						查询优化时，索引合并的代价不会被计入，故被低估查询代价

​					在单个多属性中按属性的选择性从高到低排序是效率最高的

​				**聚簇索引：**

​					优点：相关数据保存在一起，可以减少磁盘I/O，无需回表，数据访问更快。

​					缺点：这个设计是为了提高I/O密集型应用的性能，如果数据全部在内存中，那么就没有什么优势了。

​						   元组插入的速度严重依赖于元组插入的顺序

​						   更新的代价很高

​						   如果每条元组都很大，需要更多的存储空间，全表扫描变慢

​				**覆盖索引：**

​					如果一个索引包含一个查询需要用到的所有属性。则称该索引为覆盖索引

## 	2.3.查询改写

​			查询优化器不能保证总能找到好的查询计划

​			用户基本上不能给DBMS指定查询计划

​			用户可以通过添加索引或改写查询来影响查询优化器的决策

​			如果基于现有索引对查询进行改写就能获得好的查询计划，就没有必要添加新的索引

​			例：		

```SQL
select Sno, Sname from Student 
where Ssex = 'F' or Sage = 19;
--如果在Ssex和Sage上分别建有索引，则可以将该查询改写为：
(select Sno, Sname from Students where Ssex = 'F')
union 
(select Sno, Sname from Students where Sage = 19);
```



# 3.物理存储结构的设计

## 		3.1.数据类型的选择

​			选择合理的数据类型对于提高数据库系统的性能非常重要

​			选择数据类型的原则：

​				尽量使用可以正确存储数据的最小数据类型

​				尽量选择简单的数据类型

​				若无需存储空值，则最好将属性声明为not null

## 	3.2.标识符类型的选择

​				整型：最好的选择

​				enum和set类型：糟糕的选择

​				字符串类型：糟糕的选择

## 	3.3.关系模式的设计

### 		3.3.1.关系模式的纵向划分

​				举例：

​					关系模式Students(Sno, Sname, Ssex, Sage, Sdept, Balance)

Balance表示学生校园账户的余额，频繁变化；经常按系查询学号和姓名

​	所以可以将Students划分为三个关系模式R1(Sno, Sname, Ssex, Sage),R2(Sno, Sdept),R3(Sno, Balance)，这样可以更快地按系查询学号，在R3上更新Balance时，与R1和R2上的并发查询不产生冲突

### 		3.3.2.关系模式的横向划分

​				举例：

​					关系模式Students(Sno, Sname, Ssex, Sage, Sdept)上查询的where子句中经常含有Sdept = val的条件

​	将Students中的元组按Sdept属性值划分到不同的关系中，如CS_Student，MA_Student，PH_Student

​	将含有条件Sdept = ‘CS’的查询改写成CS_Student关系上的查询